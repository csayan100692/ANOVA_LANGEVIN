library(NBTVMF)
library(NBTVMF)
library(NBTVMF)
library(NBTVMF)
library(NBTVMF)
library(NBTVMF)
library(NBTVMF)
library(NBTVMF)
x
library(NBTVMF)
install.packages("testthat")
library(NBTVMF)
NBTVMF::
# 'creates test statistic value and critical value
#' @export
#' @param x data matrix
#' @param alpha numeric variable
NBTVMF3=function(x,alpha)
{
sequence_of_n=c(nrow(x[[1]]),nrow(x[[2]]),nrow(x[[3]]))
y=vector(mode = "list", length = k)
k_hat_0=vector(mode = "list", length = k)
k_hat_hat_0=vector(mode = "list", length = k)
g=vector(mode = "list", length = k)
z=vector(mode = "list", length = k)
r_bar=array(0,k)
g_bar=array(0,k)
k_hat_0=vector(mode = "list", length = k)
p=3
k=3
D1=diag(1,nrow = (p-1),ncol = (p-1))
O=diag(0,nrow = (p-1),ncol = (p-1))
l1=list(D1=D1,D2=-D1,D3=O,D4=O,D5=D1,D6=-D1)
m=array(c("D1","D4","D2","D1","D3","D6"),c((k-1),k))
C=blockmatrix(value=m,list=l1)
C1=as.matrix(C)
#C=matrix(c(1,0,-1,rep(0,4),1,0,-1,rep(0,4),1,0,-1,rep(0,4),1,0,-1),nrow = (k-1)*(p-1),ncol = k*(p-1),byrow = TRUE) #fixing a contrast matrix
H=1000 # no of inner bootstrap simulation
inner_loop_statistic_value_array=array(0,H)
for(i in 1:k)
{
y[[i]]=c(sum(x[[i]][,1]),sum(x[[i]][,2]))
r_bar[i]=sqrt(sum(y[[i]]**2))/sequence_of_n[i]
k_hat_0[[i]]=y[[i]]/sqrt(sum(y[[i]]**2))
}
X=matrix(c(unlist(k_hat_0)),nrow = k*(p-1),ncol = 1,byrow = FALSE)
X1=C1%*%(X)
N=sum(sequence_of_n)    #calculations of Q^
Q=sqrt(N)*X1
statistic_value<-sum(abs(Q)**2)
for(h in 1:H) #inner loop
{
for(i in 1:k)
{
g[[i]] <- x[[i]][sample(nrow(x[[i]]),replace = TRUE),]
z[[i]]=c(sum(g[[i]][,1]),sum(g[[i]][,2]))
g_bar[i]=(sqrt(sum(z[[i]]**2)))
k_hat_hat_0[[i]]=z[[i]]/g_bar[i]
}
X2=matrix(c(unlist(k_hat_hat_0)),nrow = k*(p-1),ncol = 1,byrow = FALSE)
X3=C1%*%(X2-X)
N=sum(sequence_of_n)
Q1=sqrt(N)*X3
inner_loop_statistic_value=sum(abs(Q1)**2)
inner_loop_statistic_value_array[h]<-inner_loop_statistic_value
}
#inner_loop_statistic_value_array
#q<-sort(inner_loop_statistic_value_array,decreasing = FALSE) # sorting of inner bootstrap values
#critical_value<-q[(1-alpha)*H]
critical_value=quantile(inner_loop_statistic_value_array,1-alpha)
return(list(statistic_value,critical_value))
#return(critical_value)
}
library(NBTVMF)
library(circular)
library(CircStats)
library(movMF)
##########################################
sequence_of_n=c(50,60,70)
sequence_of_k=c(1,2,10)
sequence_of_mu=list(c(1,-1),c(1,-1),c(1,-1))
epoch=1000
p=3
k=3
x=vector(mode = "list", length = k)
#x=list(matrix(0,nrow=sequence_of_n[1],ncol = p-1), matrix(0,nrow=sequence_of_n[2],ncol = p-1),matrix(0,nrow=sequence_of_n[3],ncol = p-1))
y=vector(mode = "list", length = k)
r_bar=array(0,k)
k_hat_0=vector(mode = "list", length = k)
kappa_hat_b=array(0,k)
kappa_hat_t=array(0,k)
kappa_upper=array(0,k)
kappa_lower=array(0,k)
kappa_hat_t_num=array(0,k)
kappa_hat_t_den=array(0,k)
kappa_hat_t=array(0,k)
kappa_hat_n=array(0,k)
mu=list(c(0,0),c(0,0),c(0,0))
#epoch=1000
l1=array(0,epoch)
l2=array(0,epoch)
l3=array(0,epoch)
mu=matrix(c(1,-1)/sqrt(2),nrow = 2,ncol = 1,byrow = FALSE)
################################################
a.p.k=function(p,k)
{
besselI(k,p/2,expon.scaled = FALSE)/besselI(k,p/2-1,expon.scaled = FALSE)
}
phi=function(p,k)
{
k/a.p.k(p,k)
}
for(h in 1:epoch)
{
for(i in 1:k)
{
x[[i]]=rmovMF(sequence_of_n[i],sequence_of_k[i]*sequence_of_mu[[i]]/sqrt(sum(sequence_of_mu[[i]]**2)))
# x1=rmovMF(sequence_of_n[1],sequence_of_k[1]*sequence_of_mu[[1]]/sqrt(sum(sequence_of_mu[[1]]**2)))
# x2=rmovMF(sequence_of_n[2],sequence_of_k[2]*sequence_of_mu[[2]]/sqrt(sum(sequence_of_mu[[2]]**2)))
# x3=rmovMF(sequence_of_n[3],sequence_of_k[3]*sequence_of_mu[[3]]/sqrt(sum(sequence_of_mu[[3]]**2)))
# y1=c(sum(x1[,1]),sum(x1[,2]))
# y2=c(sum(x2[,1]),sum(x2[,2]))
# y3=c(sum(x3[,1]),sum(x3[,2]))
#
# r1_bar=sqrt(sum(y1**2))/sequence_of_n[1]
# r2_bar=sqrt(sum(y2**2))/sequence_of_n[2]
# r3_bar=sqrt(sum(y3**2))/sequence_of_n[3]
y[[i]]=c(sum(x[[i]][,1]),sum(x[[i]][,2]))
r_bar[i]=sqrt(sum(y[[i]]**2))/sequence_of_n[i]
k_hat_0[[i]]=y[[i]]/sqrt(sum(y[[i]]**2))
# k_hat_0[[1]]=y1/sqrt(sum(y1**2))
# k_hat_0[[2]]=y2/sqrt(sum(y2**2))
# k_hat_0[[3]]=y3/sqrt(sum(y3**2))
kappa_hat_b[i]=(r_bar[i]*(p-r_bar[i]^2))/(1-r_bar[i]^2)
kappa_hat_n[i]=kappa_hat_b[i]-(a.p.k(3,kappa_hat_b[i])-r_bar[i])/(1-a.p.k(3,kappa_hat_b[i])^2-(p-1)*a.p.k(3,kappa_hat_b[i])/kappa_hat_b[i])
kappa_upper[i]=r_bar[i]*p/(1-r_bar[i]^2)
kappa_lower[i]=(r_bar[i]*(p-2))/(1-r_bar[i]^2)
kappa_hat_t_num[i]=(kappa_lower[i]*kappa_upper[i]*phi(p,kappa_upper[i])-kappa_upper[i]*kappa_lower[i]*phi(p,kappa_lower[i]))
kappa_hat_t_den[i]=kappa_upper[i]*phi(p,kappa_upper[i])-kappa_lower[i]*phi(p,kappa_lower[i])-kappa_upper[i]+kappa_lower[i]
kappa_hat_t[i]=kappa_hat_t_num[i]/kappa_hat_t_den[i]
}
a=kappa_hat_b[1]*sqrt(sum(y[[1]]**2))*k_hat_0[[1]]+kappa_hat_b[2]*sqrt(sum(y[[2]]**2))*k_hat_0[[2]]+kappa_hat_b[3]*sqrt(sum(y[[3]]**2))*k_hat_0[[3]]
b=a/sqrt(sum(a**2))
l1[h]=1-(b%*%mu)
a1=(kappa_hat_t[1]*sqrt(sum(y[[1]]**2)))*k_hat_0[[1]]+(kappa_hat_t[2]*sqrt(sum(y[[2]]**2)))*k_hat_0[[2]]+(kappa_hat_t[3]*sqrt(sum(y[[3]]**2)))*k_hat_0[[3]]
b1=a1/sqrt(sum(a1**2))
a2=kappa_hat_n[1]*sqrt(sum(y[[1]]**2))*k_hat_0[[1]]+kappa_hat_n[2]*sqrt(sum(y[[2]]**2))*k_hat_0[[2]]+kappa_hat_n[3]*sqrt(sum(y[[3]]**2))*k_hat_0[[3]]
b2=a2/sqrt(sum(a2**2))
l2[h]=1-(b1%*%mu)
l3[h]=1-(b2%*%mu)
}
mean(l1)
x
NBTVMF3(x,0.05)
library(blockmatrix)
NBTVMF3(x,0.05)
library(NBTVMF)
install.packages("roxygen2")
library(NBTVMF)
library(NBTVMF)
pnorm(0.05,lower.tail = FALSE)
pnorm(2.439,lower.tail = FALSE)
qnorm(0.05,lower.tail = FALSE)
library(NBTVMF)
NBTVMF4()
library(NBTVMF)
library(NBTVMF)
library(NBTVMF)
0.7*0.3/80
sqrt(0.002625)
1/(8*0.05123475)
qnorm(0.01,lower.tail = FALSE)
0.87-qnorm(0.1/2,lower.tail = false)*sqrt(0.088)/sqrt(105)
0.87-qnorm(0.1/2,lower.tail = FALSE)*sqrt(0.088)/sqrt(105)
0.87+qnorm(0.1/2,lower.tail = FALSE)*sqrt(0.088)/sqrt(105)
library(NBTVMF)
